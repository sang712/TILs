"""
전형적인 DP 문제로 어떻게 풀까 고심하다가
처음에는 한 카드팩의 배수로 지불하는 값과 
모자라는 카드 개수에 해당하는 카드팩 값을 더하는 방식으로 구현하였더니
틀린 값을 얻게 되었음
이렇게 하면 그동안의 경우가 누적된다고 생각했는데 
마지막의 경우에서만 누적이 되어서 총체적으로는 카드팩을 두 종류만 사는 경우가 되어 버렸음

그래서 다음 코드로 변경하였고 실행속도가 더뎌진 걸로 봐서는 모든 경우를 저장하도록 하게 된 것 같음
dp를 따로 만들었었으나 P를 그대로 사용해도 무방하였기 때문에 P를 그대로 사용하였고
P[i]가 의미하는 것은 Pi의 카드 팩까지 사는 것을 고려했을 때 사용하게 되는 최대 비용임
"""
N = int(input())
P = [0] + list(map(int, input().split()))

for i in range(1, N + 1):
    for j in range(N + 1 - i):
        P[i + j] = max(P[i] + P[j], P[i + j])
print(P[N])