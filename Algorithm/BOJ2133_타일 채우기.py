"""
처음 문제를 확인 했을 때 2 * (3N)에 해당하는 타일을 채워야하는 문제인 줄 알고 
5분안에 문제를 풀었다가 예제를 확인하고 틀렸다는 것을 알게 되었음
그러고 문제를 이해하니 3 * N에 해당하는 타일을 채워야 하는 것이고
짝수칸만 채울 수 있다는 것을 깨닫게 되었음
처음엔 이해가 안 됐는데 채울 수 없다면 0을 반환해야 한다는 내용을 보아서 그냥 무시하기도 하였고
손으로 그려본 결과 4칸 이후 부터는 다음의 패턴이 반복되는 특별한 경우가 2개씩(상하 반전) 발현함
4칸,   6칸,        8칸
━━  ━━ ━━  ━━  ━━ ━━  ━━  ━━  ━━
┃ ━━ ┃ ┃ ━━  ━━ ┃ ┃ ━━  ━━  ━━ ┃
┃ ━━ ┃ ┃ ━━  ━━ ┃ ┃ ━━  ━━  ━━ ┃
그리하여 해당 칸을 만들 수 있는 경우의 수는 두 묶음으로 쪼개서
2칸의 경우의 수 * N-2칸의 경우의 수 중 다른 수의 칸의 경우의 수 조합없이 유일한 경우의 수
4칸의 경우의 수 * N-4칸의 경우의 수 중 다른 수의 칸의 경우의 수 조합없이 유일한 경우의 수
...
N칸을 만드는 경우의 수 중 다른 수의 칸의 경우의 수 조합 없이 유일한 경우의 수
의 합으로 구할 수 있음
"""
N = int(input())

wall = [0] * (N + 2)
wall[0] = 1
wall[2] = 3

for i in range(4, N + 1, 2):
    wall[i] = wall[i - 2] * 3 + 2
    for j in range(2, i - 3, 2):
        wall[i] += wall[j] * 2
    
print(wall[N])