"""
골드 5치고는 매우 쉽게 느껴진 문제 풀이도 얼마 걸리지 않았음
2차원 dp를 만들어서 문제를 풀었고
K-1개의 숫자를 사용하여 0부터 N의 숫자를 만든 경우를 모두 더하면
K개의 숫자를 사용하여 N개의 숫자를 만든 경우의 수가 나옴
이렇게 풀었더니 88ms가 나와서
규칙성을 확인했더니
K-1개의 숫자를 사용하여 N의 숫자를 만든 경우와
K 개의 숫자를 사용하여 N-1의 숫자를 만든 경우를 모두 더했더니 같은 값이 나와서
(위의 경우는 K-1개의 숫자를 사용하여 0부터 N-1의 숫자를 만드는 경우의 수의 합과 같기 때문)
52ms로 더 빠른 연산을 할 수 있는 후자의 코드를 제출하였음
"""
N, K = map(int, input().split())

dp = [[1] * (N + 1)] + [[1] + [0] * N for _ in range(K - 1)]
for k in range(1, K):
    for n in range(1, N + 1):
        dp[k][n] = (dp[k - 1][n] + dp[k][n - 1]) % 1_000_000_000
print(dp[K - 1][N])
